    'CR1000 Series Datalogger
'
'date: 04 April 2013
'program author: Sarah Waldo
' This program is designed for the auxiliary CR1000 datalogger to run the solenoid valves, in 
' order to prevent corruption of the LI6262 CO2 signal by electronic noise. This program simply 
' uses "PortSet" to turn the solenoids off and on. The interval can be easily switched if 
' needed, for example to integrate taking measurements off of a chamber. 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''' SETTINGS ''''''''''''''''
ConstTable
  Const TOGGLE_TIME = 3*60    'duration between switching sampling sources, seconds
  
  Const SCAN_INTV = 1         'scan frequency, seconds
  Const STATS_INTV = 30*60    'time interval of statistics output, seconds
  Const CAL_INTV = 60         'time interval of output to themistor calibration table, seconds

'' 0-495 ppb over 100-5000 mV 
'   slope of 0.05 ppb/mV with offset of -5 ppb @ 0mV
'    --> voltage divider
'   slope of 0.05 ppb/mV with offset of -2.5 ppb @ 0mV
  Const DF1_MULT = 0.05 
  Const DF1_OFF = -2.5
  Const DF2_MULT = 0.05
  Const DF2_OFF = -2.5
  
  'Closed-path CO2/H2O analyzer, presumably LI-6262
  Const CP_CO2_MULT = 1
  Const CP_CO2_OFF = 0
  Const CP_H2O_MULT = 1
  Const CP_H2O_OFF = 0
  
  'Applies to all themistors!
  ' Celcius: mult=1, offset=0
  ' Fahrenheit: mult=1.8, offset=32
  Const TMPR_MULT = 1.8
  Const TMPR_OFF = 32
EndConstTable


''''''''''''''' WIRING '''''''''''''''
'trace gas analyzer analog input
Const DF1_IO = 1 'DF
Const DF2_IO = 2 'DF

'closed-path CO2/H2O analyzer
Const CP_CO2_IO = 5 'DF
Const CP_H2O_IO = 6 'DF

'aspirated temperature sensors
Const TMPR_BTM_IO = 14 'SE
Const TMPR_MID_IO = 15 'SE
Const TMPR_TOP_IO = 16 'SE
Const TMPR_VX_IO = Vx3

'level-selection valves
Const VALVE_1_CTRL = 7   'C7
' Valve 1 controls selection of bottom- or top-level sampling lines
'   Normally Open ---------- Bottom level (closest to ground) inlet
'   Normally Closed -------- Top level (farthest from fround) inlet
'   Common ----------------- EITHER (a) to analyzer delivery 
'                                   (b) Valve #2 NO
Const VALVE_2_CTRL = 8   'C8
' Valve 2 controls selection of mid-level sampling line or other valve (top/btm lines)
'   Normally Open ---------- Valve #1 Common 
'   Normally Closed -------- Middle level (between bottom, top) inlet
'   Common ----------------- To analyzer delivery


''''''''''''''' CONSTANTS ''''''''''''''''
Const INTEG = 250


''''''''''''''' VARIABLES ''''''''''''''''
'public view of valve status
Public valve_state As String * 8
Const TOP = "top"
Const MIDDLE = "middle"
Const BOTTOM = "bottom"

'measurements from DF1, DF2
Public raw_conc(2)
Alias raw_conc(1) = ch1_value
Alias raw_conc(2) = ch2_value

'level-partitioned readings of DF1, DF2
Public conc(6)
Alias conc(1) = ch1_btm
Alias conc(2) = ch1_mid
Alias conc(3) = ch1_top
Alias conc(4) = ch2_btm
Alias conc(5) = ch2_mid
Alias conc(6) = ch2_top

'measurements from closed-path CO2/H2O analyzer
Public raw_cp_irga(2)
Alias raw_cp_irga(1) = cp_CO2_value
Alias raw_cp_irga(2) = cp_H2O_value

'level-partitioned readings of closed-path CO2/H2O
Public cp_irga(6)
Alias cp_irga(1) = cp_CO2_btm
Alias cp_irga(2) = cp_CO2_mid
Alias cp_irga(3) = cp_CO2_top
Alias cp_irga(4) = cp_H2O_btm
Alias cp_irga(5) = cp_H2O_mid
Alias cp_irga(6) = cp_H2O_top

'measurements from aspirated themistors
Public tmpr(3)
Alias tmpr(1) = tmpr_btm
Alias tmpr(2) = tmpr_mid
Alias tmpr(3) = tmpr_top
Units tmpr = degF  'depends on mult/offset constants

'data logger built-in sensors
Public logger_temp, logger_voltage
Units logger_temp = degC
Units logger_voltage = volts

Dim num_levels = {2} '2 or 3, determines if mid level is sampled

'level-selection valve control
Dim valve_on(2) As Boolean
Alias valve_on(1) = is_sampling_top 'else bottom
Alias valve_on(2) = is_sampling_mid 'else top or bottom

'control whether/where themistor data is stored
Const Normal = -1
Const Calibrating = -2
Const Disabled = -3
Dim thermistor_state = {Normal}


''''''''''''''' DATA TABLES ''''''''''''''''
DataTable (gradient_tsdata,1,-1)
	DataInterval (0,SCAN_INTV,Sec,1)
  CardOut(1,-1)

	Sample(1,is_sampling_top,Boolean)
	Sample(1,is_sampling_mid,Boolean)

  Sample(1,ch1_value,IEEE4)
  Sample(1,ch2_value,IEEE4)
  
  Sample(1,cp_CO2_value,IEEE4)
  Sample(1,cp_H2O_value,IEEE4)
  
  Sample(1,(thermistor_state=Calibrating),Boolean)
  FieldNames("calibrating_tmpr")
  Sample(1,(thermistor_state=Disabled),Boolean)
  FieldNames("tmpr_is_disabled")

  Sample(1,tmpr_btm,IEEE4)
  Sample(1,tmpr_mid,IEEE4)
  Sample(1,tmpr_top,IEEE4)
EndTable

DataTable(gradient_stats,1,-1)
  DataInterval(0,STATS_INTV,Sec,10)
  CardOut(1,-1)
  
  Average(1,ch1_btm,IEEE4,ch1_btm=NAN)
  StdDev(1,ch1_btm,FP2,ch1_btm=NAN)
  Average(1,ch1_mid,IEEE4,ch1_mid=NAN)
  StdDev(1,ch1_mid,FP2,ch1_mid=NAN)
  Average(1,ch1_top,IEEE4,ch1_top=NAN)
  StdDev(1,ch1_top,FP2,ch1_top=NAN)
  
  Average(1,ch2_btm,IEEE4,ch2_btm=NAN)
  StdDev(1,ch2_btm,FP2,ch2_btm=NAN)
  Average(1,ch2_mid,IEEE4,ch2_mid=NAN)
  StdDev(1,ch2_mid,FP2,ch2_top=NAN)
  Average(1,ch2_top,IEEE4,ch2_top=NAN)
  StdDev(1,ch2_top,FP2,ch2_top=NAN)

  Average(1,cp_CO2_btm,IEEE4,cp_CO2_btm=NAN)
  StdDev(1,cp_CO2_btm,FP2,cp_CO2_btm=NAN)
  Average(1,cp_CO2_mid,IEEE4,cp_CO2_mid=NAN)
  StdDev(1,cp_CO2_mid,FP2,cp_CO2_mid=NAN)
  Average(1,cp_CO2_top,IEEE4,cp_CO2_top=NAN)
  StdDev(1,cp_CO2_top,FP2,cp_CO2_top=NAN)

  Average(1,cp_H2O_btm,IEEE4,cp_H2O_btm=NAN)
  StdDev(1,cp_H2O_btm,FP2,cp_H2O_btm=NAN)
  Average(1,cp_H2O_mid,IEEE4,cp_H2O_mid=NAN)
  StdDev(1,cp_H2O_mid,FP2,cp_H2O_mid=NAN)
  Average(1,cp_H2O_top,IEEE4,cp_H2O_top=NAN)
  StdDev(1,cp_H2O_top,FP2,cp_H2O_top=NAN)

  Average(1,tmpr_btm,FP2,tmpr_btm=NAN OR thermistor_state<>Normal)
  StdDev(1,tmpr_btm,FP2,tmpr_btm=NAN OR thermistor_state<>Normal)
  Average(1,tmpr_mid,FP2,tmpr_mid=NAN OR thermistor_state<>Normal)
  StdDev(1,tmpr_mid,FP2,tmpr_mid=NAN OR thermistor_state<>Normal)
  Average(1,tmpr_top,FP2,tmpr_top=NAN OR thermistor_state<>Normal)
  StdDev(1,tmpr_top,FP2,tmpr_top=NAN OR thermistor_state<>Normal)
  
  Average(1,logger_voltage,FP2,logger_voltage=NAN)
  Average(1,logger_temp,FP2,logger_temp=NAN)
EndTable

DataTable(tmpr_cal,(thermistor_state=Calibrating),-1)
  DataInterval(0,CAL_INTV,Sec,10)
  CardOut(1,-1)
  Average(1,tmpr_btm,IEEE4,tmpr_btm=NAN)
  StdDev(1,tmpr_btm,IEEE4,tmpr_btm=NAN)
  Average(1,tmpr_mid,IEEE4,tmpr_mid=NAN)
  StdDev(1,tmpr_mid,IEEE4,tmpr_mid=NAN)
  Average(1,tmpr_top,IEEE4,tmpr_top=NAN)
  StdDev(1,tmpr_top,IEEE4,tmpr_top=NAN)
EndTable


''''''''''''''' MENU '''''''''''''''
DisplayMenu("Sensor setup", 0)
  SubMenu("Gas gradient")
    MenuItem("# levels", num_levels)
      MenuPick(2,3)
  EndSubMenu
  SubMenu("Thermistors")
    MenuItem("Set mode", thermistor_state)
      MenuPick(Normal, Calibrating, Disabled)
  EndSubMenu
EndMenu


''''''''''''''' MAIN PROGRAM '''''''''''''''
BeginProg
  is_sampling_top = False
  is_sampling_mid = False
  'no need for bottom state indicator; both top/mid false implies bottom=true
  
  Move(raw_conc(1),2,NAN,1)
  Move(conc(1),6,NAN,1)
  Move(raw_cp_irga(1),2,NAN,1)
  Move(cp_irga(1),6,NAN,1)
  Move(tmpr(1),3,NAN,1)
  
  ' TODO verify toggle timer is a factor of stats interval ??
  '         at least verify it's a factor of one day 
  '
  ' If (USE_3_LEVELS) Then
  '   If ( STAT_INT MOD (3 * TOGGLE_TIME)) Then
  ' ...
  
	Scan (SCAN_INTV,Sec,0,0)
  
    VoltDiff(ch1_value,1,mv5000,DF1_IO,1,0,INTEG,DF1_MULT,DF1_OFF)
    VoltDiff(ch2_value,1,mv5000,DF2_IO,1,0,INTEG,DF2_MULT,DF2_OFF)

    VoltDiff(cp_CO2_value,1,mv5000,CP_CO2_IO,1,0,INTEG,CP_CO2_MULT,CP_CO2_OFF)
    VoltDiff(cp_H2O_value,1,mv5000,CP_H2O_IO,1,0,INTEG,CP_H2O_MULT,CP_H2O_OFF)

    Therm107(tmpr_btm,1,TMPR_BTM_IO,TMPR_VX_IO,0,INTEG,TMPR_MULT,TMPR_OFF)
    If (num_levels = 3) Then
      Therm107(tmpr_mid,1,TMPR_MID_IO,TMPR_VX_IO,0,INTEG,TMPR_MULT,TMPR_OFF)
    EndIf
    Therm107(tmpr_top,1,TMPR_TOP_IO,TMPR_VX_IO,0,INTEG,TMPR_MULT,TMPR_OFF)

		PanelTemp (logger_temp,INTEG)
		Battery (logger_voltage)

    If ( TimeIntoInterval(0,TOGGLE_TIME,Sec)) Then 
      If (num_levels = 3) Then
        If (is_sampling_mid) Then
          is_sampling_top = True
          is_sampling_mid = False
          valve_state = TOP
        ElseIf (is_sampling_top) Then
          is_sampling_top = False
          'is_sampling_mid should still be False
          valve_state = BOTTOM
        Else
          'is_sampling_top should still be False
          is_sampling_mid = True
          valve_state = MIDDLE
        EndIf
      Else 'FOR ONLY TWO LEVELS
        is_sampling_top = NOT is_sampling_top
        is_sampling_mid = False 'catch case of switch 3->2 levels while sampling mid
        valve_state = IIF(is_sampling_top, TOP, BOTTOM)
      EndIf
      
      PortSet(VALVE_1_CTRL, is_sampling_top)
      PortSet(VALVE_2_CTRL, is_sampling_mid)
      Move(conc(1),6,NAN,1)
      Move(cp_irga(1),6,NAN,1)
    EndIf

    'record measurements into correct level variable set
    'other variables are set to NAN during source level transition
    If (is_sampling_mid) Then
      ch1_mid = ch1_value
      ch2_mid = ch2_value
      cp_CO2_mid = cp_CO2_value
      cp_H2O_mid = cp_H2O_value
    ElseIf (is_sampling_top) Then
      ch1_top = ch1_value
      ch2_top = ch2_value
      cp_CO2_top = cp_CO2_value
      cp_H2O_top = cp_H2O_value
    Else
      ch1_btm = ch1_value
      ch2_btm = ch2_value
      cp_CO2_btm = cp_CO2_value
      cp_H2O_btm = cp_H2O_value
    EndIf
       
		CallTable gradient_tsdata
		CallTable gradient_stats
		CallTable tmpr_cal
	NextScan
EndProg


